=======================================
"Exploiting Buffer Overflow" Example 2
=======================================

In the first StackMachineBufferOverflowExample 1 shared from the project repository, adverasaries or attackers cannot easily take full control, 
or advantage of it. 
In this program, we can get a vulnerable buffer overflow program to run our code, this means, the attacker can take full control of the program.

Stack Machine Vulnerable Program
--------------------------------
.. code-block:: C

    /**
    * vulnerable program with provided user input control 
    */
    /* This program has a buffer overflow vulnerability. */

    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>

    int foo(char *str)
    {
       char buffer[100];
       /* The following statement has a buffer overflow problem */
       strcpy(buffer, str);

       return 1;
    }

    int main(int argc, char **argv)
    {
       char str[300];    // reads 300 bytes 
       FILE *riskfile;
       riskfile = fopen("riskfile", "r");
       fread(str, sizeof(char), 300, riskfile);
       foo(str);
       printf("returned \n");
        
       return 1;
    }

The above program reads 300 bytes of data from a file "riskfile". It copies the 300 bytes to a buffer of size 100. 
This creates a buffer overflow. 

In this program, the contents to be copied are in the full control of the user, and this is a likely scenario with real applications,
where the user provides input to the programs. 

As opposed to the first Stack Machine buffer overflow example1, in this program, the attacker can take advantage since the user can 
control what to copy to the program memory buffer. 

Therefore, after we overflow the buffer, we can get the program run our code, possible malicious code can take advantage. 
If the attacker places malicious code into the memory of the running program, which is not that hard, when the program start reading from 
the "riskfile", the malicious code could be loaded into the str [] array, and when the program starts copying the content of this 
str[] to the buffer, the malicious code will then be stored on the program stack. 

Therefore, the attacker can then force the running program to jump to the malicious code already in the program memory. 
With buffer overflow vulnerability, we can overwrite the return address. 

If we know the address of malicious code, the attacker can use this address to overwrite the return address. 
As result, when the function foo() returns, it could jump to the new address where the attacker malicious code is stored. 


